<h2 align="center">多代理编排器&nbsp;<img alt="静态徽章" src="https://img.shields.io/badge/Beta-4e9bcd"></h2>
<p align="center">一个灵活而强大的框架，用于管理多个 AI 代理和处理复杂对话。</p>
<p align="center">
  <a href="https://github.com/awslabs/multi-agent-orchestrator"><img alt="GitHub 仓库" src="https://img.shields.io/badge/GitHub-Repo-green.svg" /></a>
  <a href="https://www.npmjs.com/package/multi-agent-orchestrator"><img alt="npm" src="https://img.shields.io/npm/v/multi-agent-orchestrator.svg?style=flat-square"></a>
  <a href="https://pypi.org/project/multi-agent-orchestrator/"><img alt="PyPI" src="https://img.shields.io/pypi/v/multi-agent-orchestrator.svg?style=flat-square"></a>
  <a href="https://awslabs.github.io/multi-agent-orchestrator/"><img alt="文档" src="https://img.shields.io/badge/docs-book-blue.svg?style=flat-square"></a>
</p>

## 🔖 特性

- 🧠 **智能意图分类** — 根据上下文和内容动态路由查询到最合适的代理。
- 🔤 **双语言支持** — 完全实现于 **Python** 和 **TypeScript**。
- 🌊 **灵活的代理响应** — 支持来自不同代理的流式和非流式响应。
- 📚 **上下文管理** — 在多个代理间维护和利用对话上下文，实现连贯互动。
- 🔧 **可扩展架构** — 轻松集成新代理或定制现有代理以满足特定需求。
- 🌐 **通用部署** — 可在任何环境中运行 - 从 AWS Lambda 到本地环境或任意云平台。
- 📦 **预构建的代理和分类器** — 提供多种现成可用的代理和多种分类器实现。

## 什么是多代理编排器 ❓

多代理编排器是一个灵活的框架，用于管理多个 AI 代理和处理复杂对话。它智能地路由查询并维护交互中的上下文。

该系统提供预构建的组件以便快速部署，同时允许轻松集成自定义代理和对话消息存储解决方案。

这种适应性使其适用于从简单的聊天机器人到复杂的 AI 系统的广泛应用，满足多样化的需求并高效扩展。

## 🏗️ 高级架构流程图

<br /><br />

![高级架构流程图](https://raw.githubusercontent.com/awslabs/multi-agent-orchestrator/main/img/flow.jpg)

<br /><br />

1. 该过程始于用户输入，输入被分类器分析。
2. 分类器利用代理的特征和代理的对话历史选择最合适的代理来执行任务。
3. 一旦选择了代理，代理将处理用户输入。
4. 然后，编排器保存对话，更新代理的对话历史，最后将响应传递给用户。


## 💬 演示应用

为了快速体验多代理编排器，我们提供了一个演示应用，包含几个基本代理。该互动演示展示了编排器在用户友好界面中的能力。有关设置和运行演示应用的详细信息，请参阅我们的 [演示应用](https://awslabs.github.io/multi-agent-orchestrator/deployment/demo-web-app/) 部分。

<br>

在下面的屏幕录制中，我们展示了一个扩展版本的演示应用，使用了 6 个专门的代理：
- **旅行代理**：由 Amazon Lex Bot 提供支持
- **天气代理**：利用 Bedrock LLM 代理和查询 open-meteo API 的工具
- **餐厅代理**：实现为 Amazon Bedrock 代理
- **数学代理**：利用 Bedrock LLM 代理和两个执行数学运算的工具
- **技术代理**：设计用于回答技术主题问题的 Bedrock LLM 代理
- **健康代理**：专注于处理健康相关查询的 Bedrock LLM 代理

观看系统在不同主题间无缝切换的过程，从预订航班到查询天气、解决数学问题以及提供健康信息。注意每个查询选择合适的代理，保持连贯性。

演示突显了系统在处理复杂多轮对话时的能力，同时保持上下文并利用跨不同领域的专业代理。

![](https://raw.githubusercontent.com/awslabs/multi-agent-orchestrator/main/img/demo-app.gif?raw=true)

## 🚀 快速入门

查看我们的 [文档](https://awslabs.github.io/multi-agent-orchestrator/) ，获取关于设置和使用多代理编排器的全面指南！

## 🌟 用例和实现

发现多代理编排器的创意实现和多样化应用：

- **[从“Bonjour”到“登机牌”：用于航班预订的多语言 AI 聊天机器人](https://community.aws/content/2lCi8jEKydhDm8eE8QFIQ5K23pF/from-bonjour-to-boarding-pass-multilingual-ai-chatbot-for-flight-reservations)**

  本文演示了如何使用多代理编排器框架构建一个多语言聊天机器人。文章解释了如何将 **Amazon Lex** 机器人作为代理，与其他 2 个新代理配合，仅需几行代码即可支持多种语言。

- **[超越自动回复：构建 AI 驱动的电子商务支持系统](https://community.aws/content/2lq6cYYwTYGc7S3Zmz28xZoQNQj/beyond-auto-replies-building-an-ai-powered-e-commerce-support-system)**

  本文演示了如何构建一个用于自动化电子商务客户电子邮件支持的 AI 驱动多代理系统。它涵盖了使用多代理编排器框架的专用 AI 代理的架构和设置，集成自动处理与人类监督的结合。

### TypeScript 版本

#### 安装

```bash
npm install multi-agent-orchestrator
```
#### 用法

以下示例演示了如何使用多代理编排器与两种不同类型的代理：一个具有对话 API 支持的 Bedrock LLM 代理和一个 Lex Bot 代理。这展示了系统在集成各种 AI 服务方面的灵活性。

```typescript
import { MultiAgentOrchestrator, BedrockLLMAgent, LexBotAgent } from "multi-agent-orchestrator";

const orchestrator = new MultiAgentOrchestrator();

// 添加支持 Converse API 的 Bedrock LLM 代理
orchestrator.addAgent(
  new BedrockLLMAgent({
      name: "技术代理",
      description:
        "专注于技术领域，包括软件开发、硬件、人工智能、网络安全、区块链、云计算、新兴技术创新及与技术产品和服务相关的定价/成本等。",
      streaming: true
  })
);

// 添加处理旅行相关查询的 Lex Bot 代理
orchestrator.addAgent(
  new LexBotAgent({
    name: "旅行代理",
    description: "帮助用户预订和管理航班预订",
    botId: process.env.LEX_BOT_ID,
    botAliasId: process.env.LEX_BOT_ALIAS_ID,
    localeId: "en_US",
  })
);

// 示例用法
const response = await orchestrator.routeRequest(
  "我想预订一个航班",
  'user123',
  'session456'
);

// 处理响应（流式或非流式）
if (response.streaming == true) {
    console.log("\n** 响应流式 ** \n");
    // 立即发送元数据
    console.log(`> 代理 ID: ${response.metadata.agentId}`);
    console.log(`> 代理名称: ${response.metadata.agentName}`);
    console.log(`> 用户输入: ${response.metadata.userInput}`);
    console.log(`> 用户 ID: ${response.metadata.userId}`);
    console.log(`> 会话 ID: ${response.metadata.sessionId}`);
    console.log(
      `> 其他参数:`,
      response.metadata.additionalParams
    );
    console.log(`\n> 响应: `);

    // 流式输出内容
    for await (const chunk of response.output) {
      if (typeof chunk === "string") {
        process.stdout.write(chunk);
      } else {
        console.error("收到意外的块类型:", typeof chunk);
      }
    }

} else {
    // 处理非流式响应（AgentProcessingResult）
    console.log("\n** 响应 ** \n");
    console.log(`> 代理 ID: ${response.metadata.agentId}`);
    console.log(`> 代理名称: ${response.metadata.agentName}`);
    console.log(`> 用户输入: ${response.metadata.userInput}`);
    console.log(`> 用户 ID: ${response.metadata.userId}`);
    console.log(`> 会话 ID: ${response.metadata.sessionId}`);
    console.log(
      `> 其他参数:`,
      response.metadata.additionalParams
    );
    console.log(`\n> 响应: ${response.output}`);
}



### Python 版本

#### 安装

```bash
# 可选：设置虚拟环境
python -m venv venv
source venv/bin/activate  # 在 Windows 上使用 `venv\Scripts\activate`
pip install multi-agent-orchestrator
```

#### 使用方法

以下是一个等效的 Python 示例，演示如何使用 Multi-Agent Orchestrator 与 Bedrock LLM 代理和 Lex Bot 代理：

```python
import os
import asyncio
from multi_agent_orchestrator.orchestrator import MultiAgentOrchestrator
from multi_agent_orchestrator.agents import BedrockLLMAgent, LexBotAgent, BedrockLLMAgentOptions, LexBotAgentOptions, AgentCallbacks

orchestrator = MultiAgentOrchestrator()


class BedrockLLMAgentCallbacks(AgentCallbacks):
    def on_llm_new_token(self, token: str) -> None:
        # 在这里处理响应流
        print(token, end='', flush=True)

tech_agent = BedrockLLMAgent(BedrockLLMAgentOptions(
  name="技术代理",
  streaming=True,
  description="专注于技术领域，包括软件开发、硬件、人工智能、网络安全、区块链、云计算、新兴技术创新，以及与技术产品和服务相关的定价/成本。",
  model_id="anthropic.claude-3-sonnet-20240229-v1:0",
  callbacks=BedrockLLMAgentCallbacks()
))
orchestrator.add_agent(tech_agent)

# 添加一个 Lex Bot 代理以处理与旅行相关的查询
orchestrator.add_agent(
    LexBotAgent(LexBotAgentOptions(
        name="旅行代理",
        description="帮助用户预订和管理航班",
        bot_id=os.environ.get('LEX_BOT_ID'),
        bot_alias_id=os.environ.get('LEX_BOT_ALIAS_ID'),
        locale_id="zh_CN",
    ))
)

async def main():
    # 示例用法
    response = await orchestrator.route_request(
        "我想预订一张航班",
        'user123',
        'session456'
    )

    # 处理响应（流式或非流式）
    if response.streaming:
        print("\n** 响应流式 ** \n")
        # 立即发送元数据
        print(f"> 代理 ID: {response.metadata.agent_id}")
        print(f"> 代理名称: {response.metadata.agent_name}")
        print(f"> 用户输入: {response.metadata.user_input}")
        print(f"> 用户 ID: {response.metadata.user_id}")
        print(f"> 会话 ID: {response.metadata.session_id}")
        print(f"> 其他参数: {response.metadata.additional_params}")
        print("\n> 响应: ")

        # 流式内容
        async for chunk in response.output:
            if isinstance(chunk, str):
                print(chunk, end='', flush=True)
            else:
                print(f"收到意外的块类型: {type(chunk)}", file=sys.stderr)

    else:
        # 处理非流式响应（代理处理结果）
        print("\n** 响应 ** \n")
        print(f"> 代理 ID: {response.metadata.agent_id}")
        print(f"> 代理名称: {response.metadata.agent_name}")
        print(f"> 用户输入: {response.metadata.user_input}")
        print(f"> 用户 ID: {response.metadata.user_id}")
        print(f"> 会话 ID: {response.metadata.session_id}")
        print(f"> 其他参数: {response.metadata.additional_params}")
        print(f"\n> 响应: {response.output.content}")

if __name__ == "__main__":
    asyncio.run(main())

这些示例展示了：
1. 使用支持 Converse API 的 Bedrock LLM 代理，允许进行多轮对话。
2. 集成 Lex Bot 代理以处理专业任务（在这种情况下，与旅行相关的查询）。
3. 编排器能够根据输入将请求路由到最合适的代理。
4. 处理来自不同类型代理的流式和非流式响应。

📚 特别文章
我们很高兴分享展示多代理编排器的力量和灵活性的贡献。请查看这篇特色文章：

从“Bonjour”到“登机牌”：多语言 AI 聊天机器人用于航班预订
几分钟内创建全球航班预订聊天机器人！本教程引导您使用多代理编排器框架构建多语言聊天机器人。学习如何轻松链接 AI 代理，实现即时语言处理和多语言预订。将复杂的多步骤过程转变为多语言航班预订系统。

## 🤝 贡献

我们欢迎贡献！请参阅我们的 [贡献指南](https://raw.githubusercontent.com/awslabs/multi-agent-orchestrator/main/CONTRIBUTING.md) 了解更多详细信息。

## 📄 许可证

本项目遵循 Apache 2.0 许可证 - 详见 [LICENSE](https://raw.githubusercontent.com/awslabs/multi-agent-orchestrator/main/LICENSE) 文件。

## 📄 字体许可证
本项目使用 JetBrainsMono NF 字体，依据 SIL 开放字体许可证 1.1 授权。
有关完整的许可证详情，请参阅 [FONT-LICENSE.md](https://github.com/JetBrains/JetBrainsMono/blob/master/OFL.txt)。
